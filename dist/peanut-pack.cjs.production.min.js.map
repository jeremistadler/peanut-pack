{"version":3,"file":"peanut-pack.cjs.production.min.js","sources":["../src/calcNumberPrecision.ts","../src/runLengthEncode.ts","../src/runLengthEncodeBitMap.ts","../src/deltaEncode.ts","../src/runLengthDecodeGenerator.ts","../src/runLengthDecode.ts","../src/deltaDecode.ts","../src/decompressGenerator.ts","../src/compresser.ts","../src/calculateStats.ts","../src/Header.ts"],"sourcesContent":["export function calcNumberPrecision(a: number) {\n  if (!isFinite(a)) return 0\n  var e = 1,\n    p = 0\n  while (Math.round(a * e) / e !== a) {\n    e *= 10\n    p++\n  }\n  return p\n}\n","import { IndexableArray } from './IndexableArray'\nimport {\n  IS_REPEATED_RANGE,\n  IS_ONE_ITEM_RANGE,\n  IS_TWO_ITEM_RANGE,\n  IS_32_BIT_VALUES,\n  IS_16_BIT_VALUES,\n  IS_32_BIT_ITEM_RANGE,\n  IS_16_BIT_ITEM_RANGE,\n  IS_8_BIT_ITEM_RANGE,\n  IS_32_BIT_FLOAT,\n  IS_64_BIT_FLOAT,\n  IS_8_BIT_VALUES,\n} from './runLengthEncodeBitMap'\n\nfunction appendSingleItems(\n  values: IndexableArray,\n  startIndex: number,\n  endIndexInclusive: number,\n  valueSize: 162 | 226 | 0 | 32 | 96,\n): Buffer {\n  const itemCount = endIndexInclusive - startIndex + 1\n  let countBitSize = 0 // itemCount >= 65536 ? 4 : itemCount >= 255 ? 2 : 1\n\n  let flags = valueSize\n  if (itemCount === 1) flags |= IS_ONE_ITEM_RANGE\n  else if (itemCount === 2) flags |= IS_TWO_ITEM_RANGE\n  else if (itemCount < 256) {\n    flags |= IS_8_BIT_ITEM_RANGE\n    countBitSize = 1\n  } else if (itemCount < 65536) {\n    flags |= IS_16_BIT_ITEM_RANGE\n    countBitSize = 2\n  } else {\n    flags |= IS_32_BIT_ITEM_RANGE\n    countBitSize = 4\n  }\n\n  const buff = Buffer.allocUnsafe(\n    countBitSize + valueSizeToBitSize(valueSize) * itemCount + 1,\n  )\n  buff.writeUint8(flags, 0)\n\n  if (countBitSize === 1) buff.writeUInt8(itemCount, 1)\n  else if (countBitSize === 2) buff.writeUInt16LE(itemCount, 1)\n  else if (countBitSize === 4) buff.writeUInt32LE(itemCount, 1)\n\n  let offset = 1 + countBitSize\n\n  if (valueSize === IS_8_BIT_VALUES) {\n    for (let i = startIndex; i <= endIndexInclusive; i++) {\n      buff.writeInt8(values[i], offset)\n      offset += 1\n    }\n  } else if (valueSize === IS_16_BIT_VALUES) {\n    for (let i = startIndex; i <= endIndexInclusive; i++) {\n      buff.writeInt16LE(values[i], offset)\n      offset += 2\n    }\n  } else if (valueSize === IS_32_BIT_VALUES) {\n    for (let i = startIndex; i <= endIndexInclusive; i++) {\n      buff.writeInt32LE(values[i], offset)\n      offset += 4\n    }\n  } else if (valueSize === IS_32_BIT_FLOAT) {\n    for (let i = startIndex; i <= endIndexInclusive; i++) {\n      buff.writeFloatLE(values[i], offset)\n      offset += 4\n    }\n  } else if (valueSize === IS_64_BIT_FLOAT) {\n    for (let i = startIndex; i <= endIndexInclusive; i++) {\n      buff.writeDoubleLE(values[i], offset)\n      offset += 8\n    }\n  } else {\n    throw new Error(\n      'Unsupported flags in appendSingleItems ' + flags.toString(2),\n    )\n  }\n  return buff\n}\n\nfunction appendRepeatedItems(value: number, itemCount: number) {\n  const valueSize = calculateValueSizeFlag(value)\n  const sizeBit = calculateUnsignedBitSize(itemCount)\n\n  let flags = valueSize | IS_REPEATED_RANGE\n  if (itemCount === 1) flags |= IS_ONE_ITEM_RANGE\n  else if (itemCount === 2) flags |= IS_TWO_ITEM_RANGE\n  else if (sizeBit === 1) flags |= IS_8_BIT_ITEM_RANGE\n  else if (sizeBit === 2) flags |= IS_16_BIT_ITEM_RANGE\n  else if (sizeBit === 4) flags |= IS_32_BIT_ITEM_RANGE\n\n  const buff = Buffer.allocUnsafe(sizeBit + valueSizeToBitSize(valueSize) + 1)\n  buff.writeUint8(flags)\n  let offset = 1 + sizeBit\n\n  if (sizeBit === 1) buff.writeUInt8(itemCount, 1)\n  else if (sizeBit === 2) buff.writeUInt16LE(itemCount, 1)\n  else if (sizeBit === 4) buff.writeUInt32LE(itemCount, 1)\n\n  if (valueSize === IS_8_BIT_VALUES) {\n    buff.writeInt8(value, offset)\n    offset += 1\n  } else if (valueSize === IS_16_BIT_VALUES) {\n    buff.writeInt16LE(value, offset)\n    offset += 2\n  } else if (valueSize === IS_32_BIT_VALUES) {\n    buff.writeInt32LE(value, offset)\n    offset += 4\n  } else if (valueSize === IS_32_BIT_FLOAT) {\n    buff.writeFloatLE(value, offset)\n    offset += 4\n  } else if (valueSize === IS_64_BIT_FLOAT) {\n    buff.writeFloatLE(value, offset)\n    offset += 8\n  } else {\n    throw new Error(\n      'Unsupported flags in appendRepeatedItems ' + flags.toString(2),\n    )\n  }\n  return buff\n}\n\nexport function runLengthEncode(values: IndexableArray): Uint8Array {\n  const buffers: Buffer[] = []\n\n  if (values.length === 0) return new Uint8Array(0)\n  // if (values.length === 1) return [1, values[0]]\n\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i]\n\n    if (i === values.length - 1) {\n      buffers.push(\n        appendSingleItems(values, i, i, calculateValueSizeFlag(value)),\n      )\n      break\n    }\n\n    const isNextSame = values[i + 1] === value\n\n    if (isNextSame) {\n      const rangeStartIndex = i\n      while (i < values.length && values[i + 1] === value) i++\n      buffers.push(appendRepeatedItems(value, i - rangeStartIndex + 1))\n    } else {\n      const bitSizeFlag = calculateValueSizeFlag(value)\n      const rangeStartIndex = i\n      while (\n        i < values.length - 1 &&\n        values[i + 1] !== values[i] &&\n        calculateValueSizeFlag(values[i + 1]) === bitSizeFlag\n      )\n        i++\n      buffers.push(appendSingleItems(values, rangeStartIndex, i, bitSizeFlag))\n    }\n  }\n\n  const concated = Buffer.concat(buffers)\n  return new Uint8Array(\n    concated.buffer,\n    concated.byteOffset,\n    concated.byteLength,\n  )\n}\n\n// function findSubsetIndex(needleIndex: number, values: IndexableArray) {\n//   if (needleIndex + 8 >= values.length - 1) return -1\n\n//   const n0 = values[needleIndex + 0]\n//   const n1 = values[needleIndex + 1]\n//   const n2 = values[needleIndex + 2]\n//   const n3 = values[needleIndex + 3]\n//   const n4 = values[needleIndex + 4]\n//   const n5 = values[needleIndex + 5]\n//   const n6 = values[needleIndex + 6]\n//   const n7 = values[needleIndex + 7]\n\n//   for (let s = Math.max(0, needleIndex - 255); s < needleIndex - 8; s++) {\n//     if (\n//       n0 === values[s + 0] &&\n//       n1 === values[s + 1] &&\n//       n2 === values[s + 2] &&\n//       n3 === values[s + 3] &&\n//       n4 === values[s + 4] &&\n//       n5 === values[s + 5] &&\n//       n6 === values[s + 6] &&\n//       n7 === values[s + 7]\n//     )\n//       return s\n//   }\n\n//   return -1\n// }\n\nfunction valueSizeToBitSize(valueSize: 162 | 226 | 0 | 32 | 96) {\n  switch (valueSize) {\n    case 162:\n      return 4 // IS_32_BIT_FLOAT\n    case 226:\n      return 8 // IS_64_BIT_FLOAT\n    case 0:\n      return 1 // IS_8_BIT_VALUES\n    case 32:\n      return 2 // IS_16_BIT_VALUES\n    case 96:\n      return 4 // IS_32_BIT_VALUES\n  }\n}\n\nfunction calculateValueSizeFlag(value: number): 162 | 226 | 0 | 32 | 96 {\n  if (value < -0x80000000 || value > 0x7fffffff || (value | 0) !== value) {\n    if (Math.abs(Math.fround(value) - value) < 0.00001) return IS_32_BIT_FLOAT\n    return IS_64_BIT_FLOAT\n  }\n\n  if (value >= -127 && value <= 127) return IS_8_BIT_VALUES\n  if (value >= -32767 && value <= 32767) return IS_16_BIT_VALUES\n  return IS_32_BIT_VALUES\n}\n\nfunction calculateUnsignedBitSize(value: number): 0 | 1 | 2 | 4 {\n  if (value <= 2) return 0\n  if (value <= 255) return 1\n  if (value <= 65536) return 2\n  return 4\n}\n","export const IS_REPEATED_RANGE = /*   */ 0b000_000_01\nexport const IS_FLOAT = /*            */ 0b000_000_10\n\nexport const ITEM_RANGE_MASK = /*     */ 0b000_111_00\nexport const IS_ZERO_ITEM_RANGE = /*  */ 0b000_000_00\nexport const IS_ONE_ITEM_RANGE = /*   */ 0b000_001_00\nexport const IS_TWO_ITEM_RANGE = /*   */ 0b000_010_00\nexport const IS_8_BIT_ITEM_RANGE = /* */ 0b000_011_00\nexport const IS_16_BIT_ITEM_RANGE = /**/ 0b000_110_00\nexport const IS_32_BIT_ITEM_RANGE = /**/ 0b000_101_00\n\nexport const IS_8_BIT_VALUES = /*     */ 0b000_000_00\nexport const IS_16_BIT_VALUES = /*    */ 0b001_000_00\nexport const IS_32_BIT_VALUES = /*    */ 0b011_000_00\nexport const IS_32_BIT_FLOAT = /*     */ 0b101_000_10\nexport const IS_64_BIT_FLOAT = /*     */ 0b111_000_10\n\n//\n//\n\nexport const TRANSFORM_DELTA = /*      */ 0b00_00_01_00\nexport const TRANSFORM_DELTA_DELTA = /**/ 0b00_00_10_00\nexport const TRANSFORM_RLE = /*        */ 0b00_00_00_01\nexport const TRANSFORM_STRING = /*     */ 0b10_00_00_00\n","import { IndexableArray } from './IndexableArray'\n\nexport function deltaEncode(values: IndexableArray) {\n  const result: number[] = []\n  let lastValue = 0\n  for (let i = 0; i < values.length; i++) {\n    const element = values[i]\n    const delta = element - lastValue\n    lastValue = element\n    result.push(delta)\n  }\n\n  return result\n}\n","import {\n  IS_REPEATED_RANGE,\n  IS_ONE_ITEM_RANGE,\n  IS_TWO_ITEM_RANGE,\n  IS_32_BIT_ITEM_RANGE,\n  IS_16_BIT_ITEM_RANGE,\n  IS_32_BIT_VALUES,\n  IS_16_BIT_VALUES,\n  IS_8_BIT_ITEM_RANGE,\n  ITEM_RANGE_MASK,\n  IS_32_BIT_FLOAT,\n  IS_64_BIT_FLOAT,\n} from './runLengthEncodeBitMap'\n\nconst float32Array = new Float32Array(1)\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer)\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nexport function* runLengthDecodeGenerator(\n  values: Uint8Array,\n  startOffset: number,\n  endIndex: number\n): Generator<number, void, void> {\n  let offset = startOffset\n\n  while (offset < endIndex) {\n    const flag = values[offset]\n    offset++\n\n    const countBits = flag & ITEM_RANGE_MASK\n    let itemCount = 0\n\n    if (countBits === IS_TWO_ITEM_RANGE) itemCount = 2\n    else if (countBits === IS_ONE_ITEM_RANGE) itemCount = 1\n    else if (countBits === IS_8_BIT_ITEM_RANGE) {\n      itemCount = values[offset]\n      offset++\n    } else if (countBits === IS_16_BIT_ITEM_RANGE) {\n      itemCount = values[offset] | (values[offset + 1] << 8)\n      offset += 2\n    } else if (countBits === IS_32_BIT_ITEM_RANGE) {\n      itemCount =\n        (values[offset] |\n          (values[offset + 1] << 8) |\n          (values[offset + 2] << 16) |\n          (values[offset + 3] << 24)) >>>\n        0\n      offset += 4\n    } else if (flag === 0) {\n      // Handle zero fills at end of data\n      break\n    }\n\n    if (flag & IS_REPEATED_RANGE) {\n      if (flag >= IS_64_BIT_FLOAT) {\n        uInt8Float64Array[0] = values[offset]\n        uInt8Float64Array[1] = values[offset + 1]\n        uInt8Float64Array[2] = values[offset + 2]\n        uInt8Float64Array[3] = values[offset + 3]\n        uInt8Float64Array[4] = values[offset + 4]\n        uInt8Float64Array[5] = values[offset + 5]\n        uInt8Float64Array[6] = values[offset + 6]\n        uInt8Float64Array[7] = values[offset + 7]\n        offset += 8\n        const value = float64Array[0]\n        for (let i = 0; i < itemCount; i++) yield value\n      } else if (flag >= IS_32_BIT_FLOAT) {\n        uInt8Float32Array[0] = values[offset]\n        uInt8Float32Array[1] = values[offset + 1]\n        uInt8Float32Array[2] = values[offset + 2]\n        uInt8Float32Array[3] = values[offset + 3]\n        offset += 4\n        const value = float32Array[0]\n        for (let i = 0; i < itemCount; i++) yield value\n      } else if (flag >= IS_32_BIT_VALUES) {\n        const value =\n          values[offset] +\n          values[offset + 1] * 2 ** 8 +\n          values[offset + 2] * 2 ** 16 +\n          (values[offset + 3] << 24)\n        offset += 4\n\n        for (let i = 0; i < itemCount; i++) yield value\n      } else if (flag >= IS_16_BIT_VALUES) {\n        const val = values[offset] + values[offset + 1] * 2 ** 8\n        const value = val | ((val & (2 ** 15)) * 0x1fffe)\n        offset += 2\n\n        for (let i = 0; i < itemCount; i++) {\n          yield value\n        }\n      } else {\n        const val = values[offset]\n        const v2 = val | ((val & (2 ** 7)) * 0x1fffffe)\n        offset++\n\n        for (let i = 0; i < itemCount; i++) {\n          yield v2\n        }\n      }\n    } else {\n      if (flag >= IS_64_BIT_FLOAT) {\n        for (let i = 0; i < itemCount; i++) {\n          uInt8Float64Array[0] = values[offset]\n          uInt8Float64Array[1] = values[offset + 1]\n          uInt8Float64Array[2] = values[offset + 2]\n          uInt8Float64Array[3] = values[offset + 3]\n          uInt8Float64Array[4] = values[offset + 4]\n          uInt8Float64Array[5] = values[offset + 5]\n          uInt8Float64Array[6] = values[offset + 6]\n          uInt8Float64Array[7] = values[offset + 7]\n          yield float64Array[0]\n          offset += 8\n        }\n      } else if (flag >= IS_32_BIT_FLOAT) {\n        for (let i = 0; i < itemCount; i++) {\n          uInt8Float32Array[0] = values[offset]\n          uInt8Float32Array[1] = values[offset + 1]\n          uInt8Float32Array[2] = values[offset + 2]\n          uInt8Float32Array[3] = values[offset + 3]\n          yield float32Array[0]\n          offset += 4\n        }\n      } else if (flag >= IS_32_BIT_VALUES) {\n        for (let i = 0; i < itemCount; i++) {\n          yield values[offset] +\n            values[offset + 1] * 2 ** 8 +\n            values[offset + 2] * 2 ** 16 +\n            (values[offset + 3] << 24)\n          offset += 4\n        }\n      } else if (flag >= IS_16_BIT_VALUES) {\n        for (let i = 0; i < itemCount; i++) {\n          const val = values[offset] + values[offset + 1] * 2 ** 8\n          yield val | ((val & (2 ** 15)) * 0x1fffe)\n          offset += 2\n        }\n      } else {\n        for (let i = 0; i < itemCount; i++) {\n          const val = values[offset]\n          yield val | ((val & (2 ** 7)) * 0x1fffffe)\n          offset++\n        }\n      }\n    }\n  }\n}\n","import {\n  IS_REPEATED_RANGE,\n  IS_ONE_ITEM_RANGE,\n  IS_TWO_ITEM_RANGE,\n  IS_32_BIT_ITEM_RANGE,\n  IS_16_BIT_ITEM_RANGE,\n  IS_32_BIT_VALUES,\n  IS_16_BIT_VALUES,\n  IS_8_BIT_ITEM_RANGE,\n  ITEM_RANGE_MASK,\n  IS_32_BIT_FLOAT,\n  IS_64_BIT_FLOAT,\n} from './runLengthEncodeBitMap'\n\nconst float32Array = new Float32Array(1)\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer)\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nexport function runLengthDecode(\n  values: Uint8Array,\n  startOffset: number,\n  endIndex: number\n): number[] {\n  const result: number[] = []\n  let offset = startOffset\n\n  const appendSingleItems = (flag: number, itemCount: number) => {\n    if (flag >= IS_64_BIT_FLOAT) {\n      for (let i = 0; i < itemCount; i++) {\n        uInt8Float64Array[0] = values[offset]\n        uInt8Float64Array[1] = values[offset + 1]\n        uInt8Float64Array[2] = values[offset + 2]\n        uInt8Float64Array[3] = values[offset + 3]\n        uInt8Float64Array[4] = values[offset + 4]\n        uInt8Float64Array[5] = values[offset + 5]\n        uInt8Float64Array[6] = values[offset + 6]\n        uInt8Float64Array[7] = values[offset + 7]\n        result.push(float64Array[0])\n        offset += 8\n      }\n    } else if (flag >= IS_32_BIT_FLOAT) {\n      for (let i = 0; i < itemCount; i++) {\n        uInt8Float32Array[0] = values[offset]\n        uInt8Float32Array[1] = values[offset + 1]\n        uInt8Float32Array[2] = values[offset + 2]\n        uInt8Float32Array[3] = values[offset + 3]\n        result.push(float32Array[0])\n        offset += 4\n      }\n    } else if (flag >= IS_32_BIT_VALUES) {\n      for (let i = 0; i < itemCount; i++) {\n        result.push(\n          values[offset] +\n            values[offset + 1] * 2 ** 8 +\n            values[offset + 2] * 2 ** 16 +\n            (values[offset + 3] << 24)\n        )\n        offset += 4\n      }\n    } else if (flag >= IS_16_BIT_VALUES) {\n      for (let i = 0; i < itemCount; i++) {\n        const val = values[offset] + values[offset + 1] * 2 ** 8\n        result.push(val | ((val & (2 ** 15)) * 0x1fffe))\n        offset += 2\n      }\n    } else {\n      for (let i = 0; i < itemCount; i++) {\n        const val = values[offset]\n        result.push(val | ((val & (2 ** 7)) * 0x1fffffe))\n        offset++\n      }\n    }\n  }\n\n  const appendRepeatedItems = (flag: number, itemCount: number) => {\n    if (flag >= IS_64_BIT_FLOAT) {\n      uInt8Float64Array[0] = values[offset]\n      uInt8Float64Array[1] = values[offset + 1]\n      uInt8Float64Array[2] = values[offset + 2]\n      uInt8Float64Array[3] = values[offset + 3]\n      uInt8Float64Array[4] = values[offset + 4]\n      uInt8Float64Array[5] = values[offset + 5]\n      uInt8Float64Array[6] = values[offset + 6]\n      uInt8Float64Array[7] = values[offset + 7]\n      offset += 8\n      const value = float64Array[0]\n      for (let i = 0; i < itemCount; i++) result.push(value)\n    } else if (flag >= IS_32_BIT_FLOAT) {\n      uInt8Float32Array[0] = values[offset]\n      uInt8Float32Array[1] = values[offset + 1]\n      uInt8Float32Array[2] = values[offset + 2]\n      uInt8Float32Array[3] = values[offset + 3]\n      offset += 4\n      const value = float32Array[0]\n      for (let i = 0; i < itemCount; i++) result.push(value)\n    } else if (flag >= IS_32_BIT_VALUES) {\n      const value =\n        values[offset] +\n        values[offset + 1] * 2 ** 8 +\n        values[offset + 2] * 2 ** 16 +\n        (values[offset + 3] << 24)\n      offset += 4\n\n      for (let i = 0; i < itemCount; i++) result.push(value)\n    } else if (flag >= IS_16_BIT_VALUES) {\n      const val = values[offset] + values[offset + 1] * 2 ** 8\n      const value = val | ((val & (2 ** 15)) * 0x1fffe)\n      offset += 2\n\n      for (let i = 0; i < itemCount; i++) {\n        result.push(value)\n      }\n    } else {\n      const val = values[offset]\n      const v2 = val | ((val & (2 ** 7)) * 0x1fffffe)\n      offset++\n\n      for (let i = 0; i < itemCount; i++) {\n        result.push(v2)\n      }\n    }\n  }\n\n  while (offset < endIndex) {\n    const flag = values[offset]\n    offset++\n\n    const countBits = flag & ITEM_RANGE_MASK\n    let itemCount = 0\n\n    if (countBits === IS_TWO_ITEM_RANGE) itemCount = 2\n    else if (countBits === IS_ONE_ITEM_RANGE) itemCount = 1\n    else if (countBits === IS_8_BIT_ITEM_RANGE) {\n      itemCount = values[offset]\n      offset++\n    } else if (countBits === IS_16_BIT_ITEM_RANGE) {\n      itemCount = values[offset] | (values[offset + 1] << 8)\n      offset += 2\n    } else if (countBits === IS_32_BIT_ITEM_RANGE) {\n      itemCount =\n        (values[offset] |\n          (values[offset + 1] << 8) |\n          (values[offset + 2] << 16) |\n          (values[offset + 3] << 24)) >>>\n        0\n      offset += 4\n    } else if (flag === 0) {\n      // Handle zero fills at end of data\n      break\n    }\n\n    if (flag & IS_REPEATED_RANGE) {\n      appendRepeatedItems(flag, itemCount)\n    } else {\n      appendSingleItems(flag, itemCount)\n    }\n  }\n\n  return result\n}\n","export function deltaDecode(data: number[]): number[] {\n  const result: number[] = []\n  let lastValue = 0\n  for (let i = 0; i < data.length; i++) {\n    const element = data[i]\n    const delta = element + lastValue\n    lastValue = delta\n    result.push(delta)\n  }\n\n  return result\n}\n\nexport function deltaDecodeGenerator() {\n  let lastValue = 0\n\n  return (val: number) => {\n    lastValue = val + lastValue\n    return lastValue\n  }\n}\n","import { runLengthDecodeGenerator } from './runLengthDecodeGenerator'\nimport { Header, readHeader } from './Header'\nimport {\n  TRANSFORM_DELTA,\n  TRANSFORM_DELTA_DELTA,\n  TRANSFORM_STRING,\n} from './runLengthEncodeBitMap'\nimport { deltaDecodeGenerator } from './deltaDecode'\n\nexport function decompressSerieGenerator(serie: Uint8Array) {\n  const header = readHeader(serie)\n\n  return {\n    stats: header,\n    values:\n      header.flags & TRANSFORM_STRING\n        ? decompressStringSerie(serie)\n        : decompressNumberSerieGenerator(serie, header),\n  }\n}\n\nfunction* decompressNumberSerieGenerator(\n  serie: Uint8Array,\n  header: Header,\n): Generator<number, void, void> {\n  let values = runLengthDecodeGenerator(\n    serie,\n    header.headerSize + 1,\n    serie.length,\n  )\n\n  const delta1 =\n    (header.flags & TRANSFORM_DELTA) === TRANSFORM_DELTA\n      ? deltaDecodeGenerator()\n      : null\n  const delta2 =\n    (header.flags & TRANSFORM_DELTA_DELTA) === TRANSFORM_DELTA_DELTA\n      ? deltaDecodeGenerator()\n      : null\n\n  for (const value of values) {\n    let val = value\n\n    if (delta1 !== null) val = delta1(val)\n    if (delta2 !== null) val = delta2(val)\n\n    yield val + header.valueOffset\n  }\n}\n\nfunction* decompressStringSerie(\n  _serie: Uint8Array,\n): Generator<string, void, void> {\n  throw new Error('Function not implemented.')\n}\n","import {\n  TRANSFORM_DELTA,\n  TRANSFORM_DELTA_DELTA,\n  TRANSFORM_RLE,\n} from './runLengthEncodeBitMap'\nimport { calculateStats } from './calculateStats'\nimport { runLengthEncode } from './runLengthEncode'\nimport {\n  AnyInputSerie,\n  InputNumberSerie,\n  InputStringSerie,\n  TransformType,\n} from './types'\nimport { deltaEncode } from './deltaEncode'\n\nexport function compressSerie(serie: AnyInputSerie): Uint8Array {\n  switch (serie.type) {\n    case 'number':\n      return compressNumberSerie(serie)\n    case 'string':\n      return compressStringSerie(serie)\n  }\n}\n\nfunction findSmallest(values: number[]) {\n  const deltaValues = deltaEncode(values)\n  const deltaRle = runLengthEncode(deltaValues)\n\n  const delta2Values = deltaEncode(deltaValues)\n  const delta2Rle = runLengthEncode(delta2Values)\n\n  const rle = runLengthEncode(values)\n\n  if (delta2Rle.length < deltaRle.length && delta2Rle.length < rle.length) {\n    return {\n      data: delta2Rle,\n      transforms: TRANSFORM_DELTA_DELTA | TRANSFORM_RLE,\n    }\n  }\n\n  if (deltaRle.length < rle.length) {\n    return {\n      data: deltaRle,\n      transforms: TRANSFORM_DELTA | TRANSFORM_RLE,\n    }\n  }\n\n  return {\n    data: rle,\n    transforms: TRANSFORM_RLE,\n  }\n}\n\nfunction compressNumberSerie(serie: InputNumberSerie): Uint8Array {\n  const stats = calculateStats(serie.values)\n\n  const valueOffset = stats.p50 > 1 ? Math.floor(stats.p50) : 0\n  let offseted = serie.values\n  if (valueOffset > 0) {\n    offseted = serie.values.map(f => f - valueOffset)\n  }\n\n  const smallest = findSmallest(offseted)\n\n  const headerData = runLengthEncode([\n    smallest.transforms,\n    valueOffset,\n    stats.count,\n    stats.unique,\n    stats.maxDecimals,\n    stats.min,\n    stats.p02,\n    stats.p05,\n    stats.p50,\n    stats.p95,\n    stats.p98,\n    stats.max,\n  ])\n\n  const final = new Uint8Array(headerData.length + 1 + smallest.data.length)\n  final[0] = headerData.length\n  final.set(headerData, 1)\n  final.set(smallest.data, 1 + headerData.length)\n\n  return final\n}\n\nexport const transformTypes: ReadonlyArray<TransformType> = [\n  'delta',\n  'rle',\n  'dictionary',\n]\n\nfunction compressStringSerie(_serie: InputStringSerie): Uint8Array {\n  throw new Error('Function not implemented.')\n}\n","import { calcNumberPrecision } from './calcNumberPrecision'\nimport percentile from 'percentile'\n\nexport function calculateStats(values: number[]) {\n  const unique = new Set(values).size\n  let min = values[0]\n  let max = values[0]\n  let maxDecimals = 0\n\n  const [p02, p05, p50, p95, p98] = percentile(\n    [2, 5, 50, 95, 98],\n    values\n  ) as number[]\n\n  for (let i = 0; i < values.length; i++) {\n    const element = values[i]\n    min = Math.min(min, element)\n    max = Math.max(max, element)\n    maxDecimals = Math.max(maxDecimals, calcNumberPrecision(element))\n  }\n\n  return {\n    unique,\n    min,\n    max,\n    count: values.length,\n    maxDecimals,\n    p02,\n    p05,\n    p50,\n    p95,\n    p98,\n  }\n}\n","import { runLengthDecode } from './runLengthDecode'\n\nexport type Header = ReturnType<typeof readHeader>\nexport function readHeader(rawData: Uint8Array) {\n  const headerSize = rawData[0]\n  const [\n    flags,\n    valueOffset,\n    count,\n    unique,\n    maxDecimals,\n    min,\n    p02,\n    p05,\n    p50,\n    p95,\n    p98,\n    max,\n  ] = runLengthDecode(rawData, 1, headerSize + 1)\n\n  return {\n    valueOffset,\n    headerSize,\n    flags,\n    count,\n    unique,\n    maxDecimals,\n    min,\n    max,\n    p02,\n    p05,\n    p50,\n    p95,\n    p98,\n  }\n}\n"],"names":["calcNumberPrecision","a","isFinite","e","p","Math","round","appendSingleItems","values","startIndex","endIndexInclusive","valueSize","itemCount","countBitSize","flags","buff","Buffer","allocUnsafe","valueSizeToBitSize","writeUint8","writeUInt8","writeUInt16LE","writeUInt32LE","offset","i","writeInt8","writeInt16LE","writeInt32LE","writeFloatLE","Error","toString","writeDoubleLE","appendRepeatedItems","value","calculateValueSizeFlag","sizeBit","calculateUnsignedBitSize","runLengthEncode","buffers","length","Uint8Array","push","rangeStartIndex","bitSizeFlag","concated","concat","buffer","byteOffset","byteLength","abs","fround","deltaEncode","result","lastValue","element","delta","float32Array","Float32Array","uInt8Float32Array","float64Array","Float64Array","uInt8Float64Array","deltaDecodeGenerator","val","decompressNumberSerieGenerator","serie","header","startOffset","endIndex","flag","countBits","v2","runLengthDecodeGenerator","headerSize","delta1","delta2","valueOffset","decompressStringSerie","_serie","type","stats","unique","Set","size","min","max","maxDecimals","p02","p05","p50","p95","p98","percentile","count","calculateStats","floor","offseted","map","f","smallest","deltaValues","deltaRle","delta2Rle","rle","data","transforms","TRANSFORM_DELTA_DELTA","TRANSFORM_DELTA","findSmallest","headerData","final","set","compressNumberSerie","compressStringSerie","rawData","runLengthDecode","readHeader"],"mappings":"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"}